module Phi_of_m

USE interface_tools_NC
USE quadpack ! if I want to use qags integration
USE utils_NC
implicit none



contains

	! =========================================================
	! Probability of having a halo of mass M with =============
	! Lambda MOCK within a given range \Delta_Lambda ==========
	function Phi_M(halo_mass)
	double precision halo_mass, x_min, x_max, sigma2_lnL, Phi_M
	double precision sig2_lnl_z,sig2_intr,Mpivot


	if (use_Plobltr) then
	    ! For P(Lambda_ob|M,z) = \int dlambda_tr P(lambda_ob| ===== 
	    ! lambda_tr,z_tr) P(lambda_tr|M,z_tr)
	    call bilin_interp(z_int_P_lobMz,M_int_P_lobMz,int_P_lob_M_z(n_L1,:,:),redshift,log(halo_mass),Phi_M)
	else
!	    ! For P(Lambda|M) Lognormal : =============================
!	    ! Phi_M = 1/2 * {erfc[x(Lambda_min)]-erfc[x(Lambda_max)]} =
!	    ! w\ x =Ln(Lambda)-<Ln(Lambda)|(M,z)>/sqrt(2*sigma_lnL^2) =
!	    ! w/ sigma_lnL^2 = 1/exp(< ln lambda|M,z> ) + \sigma^2 ====
	    if (use_HOD_LM) then
	        Mpivot=10.d0**delta_b0
	    else ! use power law lmabda-mass relation
!	        Mpivot=10.d0**14.35217d0 ! Test DES BUZZARD
	        Mpivot=10.d0**14.344d0 ! SDSS DATA
	    end if
	    if (use_powM_scatter) then
	        sig2_intr=(sig_intr*(halo_mass/Mpivot)**delta_c0)**2.d0
	    else
	        sig2_intr=(sig_intr+ delta_c0*log(halo_mass/Mpivot))**2.d0
	    end if
	    if (only_intr_scat) then
	        sigma2_lnL =sig2_intr
	    else
	        sigma2_lnL =sig2_intr + (exp(LnLambda_M(halo_mass,redshift))-1.d0)*exp(-LnLambda_M(halo_mass,redshift))**2.d0
	        if (exp(LnLambda_M(halo_mass,redshift))< 1.d0) sigma2_lnL =sig2_intr
	    end if
	    if (use_skewnorm) then  ! If P(lambda_tr|M,z_tr)=SkewNormal
	        mass=halo_mass ! mass global variable OMP THREADPRIVATE used in P_l_tr_M_z
	        call trapzd_int_1args(P_l_tr_M_z,exp(LnLambda_min),exp(LnLambda_max),redshift,Phi_M,int(min(exp(LnLambda_max)-exp(LnLambda_min),50.d0)))
	    else ! If P(lambda_tr|M,z_tr)=LogNormal
	        if (LMrel_is_mean) then ! if <ln(Lambda(M))>=ln<Lambda(M)>-0.5*Sigma is the mean of the log-norm distriubtion
	            x_min = (LnLambda_min-LnLambda_M(halo_mass,redshift)+0.5d0*sigma2_lnL)/sqrt(2.d0*sigma2_lnL)
	            x_max = (LnLambda_max-LnLambda_M(halo_mass,redshift)+0.5d0*sigma2_lnL)/sqrt(2.d0*sigma2_lnL)
	        else ! if <ln(Lambda(M))> is the mean of the log-norm distriubtion
	            x_min = (LnLambda_min-LnLambda_M(halo_mass,redshift))/sqrt(2.d0*sigma2_lnL)
	            x_max = (LnLambda_max-LnLambda_M(halo_mass,redshift))/sqrt(2.d0*sigma2_lnL)
	        end if
	        Phi_M = 0.5d0*(derfc(x_min)-derfc(x_max))
	    end if
!	!	write(*,'(10e16.8)') redshift,log10(halo_mass),sigma2_lnL,erfc(x_min),erfc(x_max),Phi_M
	end if
	return
	end function Phi_M
	! =========================================================

	! =========================================================
	function dP_l_ob_M_z(lambda_tr)
	double precision lambda_tr,dP_l_ob_M_z,dummy
	double precision int_P_lob_ltr_ztr
	
	!Interpolate for \int_Delta_lambda_i d\lambda_obs P(\lambda_obs|\lambda_tr,z_tr)
!	call ESLGQ(z_int_P_lob,l_int_P_lob,int_P_lob_ltr(n_L1,:,:),line_counter_z,line_counter_l,redshift,lambda_tr,int_P_lob_ltr_ztr)
!	write(*,*) n_L1,redshift,lambda_tr,int_P_lob_ltr_ztr
	call bilin_interp(z_int_P_lob,l_int_P_lob,int_P_lob_ltr(n_L1,:,:),redshift,lambda_tr,int_P_lob_ltr_ztr)
	if (int_P_lob_ltr_ztr<0.d0) int_P_lob_ltr_ztr=0.d0
	if (int_P_lob_ltr_ztr>1.d0) int_P_lob_ltr_ztr=1.d0

!	call bilin_interp(z_int_P_lob,l_int_P_lob,int_P_lob_ltr(4,:,:),0.75d0,1.d0,int_P_lob_ltr_ztr)
!    write(*,*) int_P_lob_ltr_ztr
!	call bilin_interp(z_int_P_lob,l_int_P_lob,int_P_lob_ltr(4,:,:),0.75d0,100.d0,int_P_lob_ltr_ztr)
!    write(*,*) int_P_lob_ltr_ztr
!    stop 24

	dP_l_ob_M_z=P_l_tr_M_z(lambda_tr,redshift)*int_P_lob_ltr_ztr

	return
	end function dP_l_ob_M_z
	! =========================================================


!	! P(lambda_tr|M,z_tr)=Normal ==============================
!	function P_l_tr_M_z(lambda_tr,z_reds)
!	double precision lambda_tr,z_reds, sigma2_L,P_l_tr_M_z
!	double precision sig2_intr,Lambda_M

!    Lambda_M=exp(LnLambda_M(mass,z_reds)) ! <lambda_tr_NOPRJ|M,z> mass\redshift = global variables
!    sig2_intr=sig_intr**2.d0
!    sigma2_L =sig2_intr*(Lambda_M)**2.d0 + (Lambda_M-1.d0) ! Questo qllo giusto in generale
!    if (Lambda_M<= 0.0d0) sigma2_L =sig2_intr*0.001d0**2.d0 ! in teoria sarebbe zero
!    P_l_tr_M_z = exp(-0.5d0*(lambda_tr-Lambda_M)**2.d0/sigma2_L)/sqrt(2.d0*pi_value*sigma2_L)
!	return
!	end function P_l_tr_M_z
!	! =========================================================

!	! P(lambda_tr|M,z_tr)=Log-Normal ==========================
!	function P_l_tr_M_z(lambda_tr,z_reds)
!	double precision lambda_tr,z_reds, sigma2_lnL,P_l_tr_M_z
!	double precision sig2_intr,Lambda_M

!    Lambda_M=exp(LnLambda_M(mass,z_reds)) ! <lambda_tr_NOPRJ|M,z> mass\redshift = global variables
!    sig2_intr=sig_intr**2.d0
!    sigma2_lnL =sig2_intr + (Lambda_M-1.d0)/(Lambda_M)**2.d0
!    if (Lambda_M< 1.d0) sigma2_lnL =sig2_intr
!    P_l_tr_M_z = exp(-0.5d0*(log(lambda_tr)-(LnLambda_M(mass,z_reds)-0.5d0*sigma2_lnL))**2.d0/sigma2_lnL)/sqrt(2.d0*pi_value*sigma2_lnL)/lambda_tr
!	return
!	end function P_l_tr_M_z
!	! =========================================================

	! P(lambda_tr|M,z_tr)=Skew-Normal =========================
	function P_l_tr_M_z(lambda_tr,z_reds)
	double precision l_sat_M,sig_skew,skew,lambda_tr,z_reds, P_l_tr_M_z,sig2_ltr,sig_intr_M,Mpivot
	double precision term1,term2

	if (use_HOD_LM) then
	    Mpivot=10.d0**delta_b0
	else ! use power law lmabda-mass relation
!	    Mpivot=10.d0**14.35217d0 ! Test DES BUZZARD
	    Mpivot=10.d0**14.344d0 ! SDSS DATA
	end if
	if (use_powM_scatter) then
	    sig_intr_M=sig_intr*(mass/Mpivot)**delta_c0
	else
	    sig_intr_M=sig_intr +delta_c0*log(mass/Mpivot)
	end if
	
	if (use_skewnorm) then ! USE P(lambda_tr|M,z_tr)=Skew-Normal
	    l_sat_M=exp(LnLambda_M(mass,z_reds))-1.d0 ! mass = global variables
	    skew=interp2d(l_sat_M,sig_intr_M,n_lsat_grid,l_sat_grid,n_sig_grid,sig_intr_grid,skew_table,ddskew_table)
	    sig_skew=interp2d(l_sat_M,sig_intr_M,n_lsat_grid,l_sat_grid,n_sig_grid,sig_intr_grid,sig_skew_table,ddsig_skew_table)
    !	call bilin_interp(l_sat_grid,sig_intr_grid,sig_skew_table,l_sat_M,sig_intr,sig_skew)
    !	call bilin_interp(l_sat_grid,sig_intr_grid,skew_table,l_sat_M,sig_intr,skew)
	    sig2_ltr=sig_skew**2.d0

	    term1=dexp(-0.5*(lambda_tr-l_sat_M)**2./sig2_ltr)
	    if (skew<=0.d0) then ! the skew-norm is Gaussian
	        term2=1.d0
	    else
	        term2=derfc(-skew*(lambda_tr-l_sat_M)/sqrt(2.d0*sig2_ltr))
	    end if
        P_l_tr_M_z = term1*term2/sqrt(2.d0*pi_value*sig2_ltr)
    !	write(*,*) lambda_tr,l_sat_M,sig_intr_M,skew,sig_skew,P_l_tr_M_z
    !	stop 24
	else ! USE P(lambda_tr|M,z_tr)=Log-Normal
	    l_sat_M=exp(LnLambda_M(mass,z_reds)) ! is actually <lambda_true> not <lambda_sat>
	    if (only_intr_scat) then
	        sig2_ltr =sig_intr_M**2.d0
	    else
	        sig2_ltr =sig_intr_M**2.d0 + (l_sat_M-1.d0)/l_sat_M**2.d0
	        if (l_sat_M< 1.d0) sig2_ltr = sig_intr_M**2.d0
	    end if
	    if (LMrel_is_mean) then ! if <ln(Lambda(M))>=ln<Lambda(M)>-0.5*Sigma is the mean of the log-norm distriubtion
	        P_l_tr_M_z = exp(-0.5d0*(log(lambda_tr)-(LnLambda_M(mass,z_reds)-0.5d0*sig2_ltr))**2.d0/sig2_ltr)/sqrt(2.d0*pi_value*sig2_ltr)/lambda_tr
	    else ! if <ln(Lambda(M))> is the mean of the log-norm distriubtion
	        P_l_tr_M_z = exp(-0.5d0*(log(lambda_tr)-LnLambda_M(mass,z_reds))**2.d0/sig2_ltr)/sqrt(2.d0*pi_value*sig2_ltr)/lambda_tr
	    end if
	end if
	return
	end function P_l_tr_M_z
	! =========================================================

	! Observable-Mass relation from HOD model =================
	function LnLambda_M(halo_mass,z_reds)
	double precision halo_mass,Mpivot, LnLambda_M,z_reds


	if (use_HOD_LM) then
	    Mpivot=10.d0**delta_b0
	    if (halo_mass>10.d0**Log10Mminsat) then ! To avoid numerical error for halo_mass==10.d0**Log10Mminsat
	        LnLambda_M=log(1.d0 + ((halo_mass-10.d0**Log10Mminsat)/Mpivot)**delta_a0*((1.d0+z_reds)/(1.d0+0.2d0))**epsi)
	    else ! by construction this should not happen
	        LnLambda_M=log(1.d0)
	    end if
	else ! use power law lmabda-mass relation
!	    Mpivot=10.d0**14.35217d0 ! Test DES BUZZARD
	    Mpivot=10.d0**14.344d0 ! SDSS DATA
	    LnLambda_M=delta_b0 + log(halo_mass/Mpivot)*delta_a0 + log((1.d0+z_reds)/(1.d0+0.2d0))*epsi
	end if
	return
	end function LnLambda_M
	! =========================================================



!	! P(lambda_tr|M,z_tr)=Skew-Normal for direct integration ==
!	function dP_l_tr_M_z(lambda_tr)
!	double precision lambda_tr,dP_l_tr_M_z
!    dP_l_tr_M_z=P_l_tr_M_z(lambda_tr,redshift)
!	return
!	end function dP_l_tr_M_z
!	! =========================================================

!	! P(lambda_ob|lambda_tr,z_tr) =============================
!	function P_lob_ltr_ztr(lambda_ob,lambda_tr,z_tr)
!	double precision lambda_tr,z_tr,lambda_ob,P_lob_ltr_ztr
!	double precision tau,mu,sig_pure,f_mask,sig2_l
!	double precision erfc_arg1,erfc_arg2,erfc_arg3,erfc_arg4,exptau,pdf
!	
!	tau=tau_model(lambda_tr,z_tr)
!	f_mask=fmask_model(lambda_tr,z_tr)
!	mu=mu_model(lambda_tr,z_tr)
!	sig_pure=sig_pure_model(lambda_tr,z_tr)
!	
!	if (tau<0.d0) tau=1.d-3
!	if (f_mask<0.d0) f_mask=0.d0
!	if (f_mask>1.d0) f_mask=1.d0
!	if (sig_pure<1.d-3) sig_pure=1.d0-3
!	sig2_l=sig_pure**2.d0
!	erfc_arg1=(mu+tau*sig2_l-lambda_ob)/sqrt(2.d0*sig2_l)
!    erfc_arg2=(lambda_ob-mu)/sqrt(2.d0*sig2_l)
!    erfc_arg3=(lambda_ob-mu+lambda_tr)/sqrt(2.d0*sig2_l)
!    erfc_arg4=(mu+tau*sig2_l-lambda_ob-lambda_tr)/sqrt(2.d0*sig2_l)
!    exptau=dexp(0.5d0*tau*(2.d0*mu+tau*sig2_l-2.d0*lambda_ob))
!    pdf=(exptau*derfc(erfc_arg1)*((1.d0-f_mask)*tau+f_mask/lambda_tr)+f_mask/lambda_tr*(derfc(erfc_arg2)-derfc(erfc_arg3)-dexp(-tau*lambda_tr)*exptau*derfc(erfc_arg4)))

!    P_lob_ltr_ztr=abs(pdf)*0.5d0
!	return
!	end function P_lob_ltr_ztr
!	! =========================================================

!	! =========================================================
!	function tau_model(lambda_tr,z_tr)
!	double precision tau_model,lambda_tr,z_tr,z_pivot
!	z_pivot=0.1d0
!	atau0=0.16694146
!	atauz=0.37591232
!	btau0=0.34212279
!	btauz=0.00554625
!    tau_model=(btau0*(z_tr/z_pivot)**btauz)/lambda_tr**(atau0*(z_tr/z_pivot)**atauz)
!	return
!	end function tau_model
!	! =========================================================
!	
!	! =========================================================
!	function fmask_model(lambda_tr,z_tr)
!	double precision fmask_model,lambda_tr,z_tr,z_pivot
!	z_pivot=0.1d0
!	af0=0.572668
!	afz=-0.60617335
!	bf0=0.01187639
!	bfz=1.74709717
!    fmask_model=(bf0*(z_tr/z_pivot)**bfz)*lambda_tr**(af0+(z_tr-z_pivot)**afz)
!	return
!	end function fmask_model
!	! =========================================================

!	! =========================================================
!	function mu_model(lambda_tr,z_tr)
!	double precision mu_model,lambda_tr,z_tr,z_pivot
!	double precision amu0,amuz,bmu0,bmuz
!	z_pivot=0.1d0
!	amu0=-0.13144983
!	amuz=1.21427908
!	bmu0=0.95813886
!	bmuz=0.04795005
!    mu_model=(bmu0*(z_tr/z_pivot)**bmuz)*lambda_tr+(amu0*(z_tr/z_pivot)**amuz)
!	return
!	end function mu_model
!	! =========================================================
!	
!	! =========================================================
!	function sig_pure_model(lambda_tr,z_tr)
!	double precision sig_pure_model,lambda_tr,z_tr,z_pivot
!	double precision asig0,asigz,bsig0,bsigz
!	z_pivot=0.1d0
!	asig0=0.29807749
!	asigz=0.20397305
!	bsig0=1.09531034
!	bsigz=0.04499273
!    sig_pure_model=(bsig0*(z_tr/z_pivot)**bsigz)*lambda_tr**(asig0*(z_tr/z_pivot)**asigz)
!	return
!	end function sig_pure_model
!	! =========================================================

!	! Observable-Mass relation from arxiv1603.06953 ===========
!	function LnLambda_M(halo_mass,z_reds)
!	double precision halo_mass, LnLambda_M,z_reds!,b0,a0


!!	LnLambda_M=b0*(1.d0+delta_b0) + log(halo_mass/(10.d0**14.344d0))*a0*(1.d0+delta_a0)
!	LnLambda_M=delta_b0 + log(halo_mass/(10.d0**14.344d0))*delta_a0
!!	LnLambda_M=delta_b0 + log(halo_mass/(10.d0**14.34846d0))*delta_a0 ! Test Buzzard
!!	LnLambda_M=delta_b0 + log(halo_mass/(10.d0**14.3484599239d0))*delta_a0
!	return
!	end function LnLambda_M
!	! =========================================================

!	! Probability of having a halo of mass M with =============
!	! Lambda MOCK within a given range \Delta_Lambda ==========
!	! For P(Lambda|M) Normal : ================================
!	! Phi_M = p/2 * {erfc[x(Lambda_min)]-erfc[x(Lambda_max)]} =
!	! + (1-p)/2 * {erfc[x(Lambda_min/(1+eps))] ================
!	! -erfc[x(Lambda_max/(1+eps))]} ===========================
!	! w\ x =Lambda-<(Lambda)|(M,z)>/sqrt(2*sigma_L^2) =========
!	! w/ sigma_L^2 = (<lambda|M,z>-1)+(\sigma<lambda|M,z>)^2 ==
!	! p = fraction of halo which is not affect by =============
!	! projection effects ======================================
!	! eps = (Lambda^ob-Lambda^true)/Lambda^true ===============
!	function Phi_M(halo_mass)
!	double precision halo_mass, x_min, x_max, sigma2_L, Phi_M_1,Phi_M_2,Phi_M
!	double precision sig2_lnl_z,sig2_intr,Lambda_M,sigma2_L_2
!!	double precision, optional 

!    Lambda_M=exp(LnLambda_M(halo_mass,redshift))
!    sig2_intr=sig_intr**2.d0
!    sigma2_L =sig2_intr + 1.d0/(Lambda_M) ! Questo qllo giusto in generale
!    if (Lambda_M< 1.0d0) sigma2_L =sig2_intr
!    Lambda_M=Lambda_M*exp(sigma2_L*(0.5-2.0))
!    sigma2_L=((exp(sigma2_L)-1.d0)*Lambda_M**2.d0)
!    sigma2_L = sigma2_L + (sigma_lambda(halo_mass,redshift))**2.d0 ! Add variance due to richenss-error
!    sigma2_L_2=sigma2_L/(1.d0-epsi)**2.d0 + (sigma_lambda(halo_mass,redshift))**2.d0
!    x_min = (exp(LnLambda_min)-Lambda_M)/sqrt(2.d0*sigma2_L)
!    x_max = (exp(LnLambda_max)-Lambda_M)/sqrt(2.d0*sigma2_L)
!    Phi_M_1 = 0.5d0*frac_p*(derfc(x_min)-derfc(x_max))
!    x_min = (exp(LnLambda_min)-Lambda_M/(1.d0-epsi))/sqrt(2.d0*sigma2_L_2)
!    x_max = (exp(LnLambda_max)-Lambda_M/(1.d0-epsi))/sqrt(2.d0*sigma2_L_2)
!    Phi_M_2 = 0.5d0*(1.d0-frac_p)*(derfc(x_min)-derfc(x_max))
!    Phi_M = Phi_M_1 + Phi_M_2
!!	write(*,'(10e16.8)') redshift,log10(halo_mass),exp(LnLambda_M(halo_mass,redshift)),sig_intr,sqrt(sig2_intr*(Lambda_M-1.d0)**2.d0 + (Lambda_M-1.d0)),sigma_lambda(halo_mass,redshift),Phi_M
!	return
!	end function Phi_M
!	! =========================================================


!	! Probability of having a halo of mass M with =============
!	! Lambda MOCK within a given range \Delta_Lambda ==========
!	! For P(Lambda|M) Lognormal : =============================
!	! Phi_M = 1/2 * {erfc[x(Lambda_min)]-erfc[x(Lambda_max)]} =
!	! w\ x =Ln(Lambda)-<Ln(Lambda)|(M,z)>/sqrt(2*sigma_lnL^2) =
!	! w/ sigma_lnL^2 = 1/exp(< ln lambda|M,z> ) + \sigma^2 ====
!	function Phi_M(halo_mass)
!	double precision halo_mass, x_min, x_max, sigma2_lnL, Phi_M  ! CANCELLAMI
!	double precision sig2_lnl_z,sig2_intr

!    sig2_intr=sig_intr**2.d0
!!    sigma2_lnL =sig2_intr + exp(-LnLambda_M(halo_mass))
!    sigma2_lnL =sig2_intr + (exp(LnLambda_M(halo_mass,redshift))-1.d0)*exp(-LnLambda_M(halo_mass,redshift))**2.d0
!    if (exp(LnLambda_M(halo_mass,redshift))< 1.d0) sigma2_lnL =sig2_intr
!!    x_min = (LnLambda_min-LnLambda_M(halo_mass,redshift))/sqrt(2.d0*sigma2_lnL)
!!    x_max = (LnLambda_max-LnLambda_M(halo_mass,redshift))/sqrt(2.d0*sigma2_lnL)
!    x_min = (LnLambda_min-LnLambda_M(halo_mass,redshift)+0.5d0*sigma2_lnL)/sqrt(2.d0*sigma2_lnL)
!    x_max = (LnLambda_max-LnLambda_M(halo_mass,redshift)+0.5d0*sigma2_lnL)/sqrt(2.d0*sigma2_lnL)
!    Phi_M = 0.5d0*(derfc(x_min)-derfc(x_max))
!!	write(*,'(10e16.8)') redshift,log10(halo_mass),sigma2_lnL,erfc(x_min),erfc(x_max),Phi_M
!	return
!	end function Phi_M
!	! =========================================================

!	! Probability of having a halo of mass M with =============
!	! Lambda MOCK within a given range \Delta_Lambda ==========
!	! For P(Lambda|M) Lognormal : =============================
!	! Phi_M = p/2 * {erfc[x(Lambda_min)]-erfc[x(Lambda_max)]} =
!	! + (1-p)/2 * {erfc[x(Lambda_min*(1-eps))] ================
!	! -erfc[x(Lambda_max*(1-eps))]} ===========================
!	! w\ x =Ln(Lambda)-<Ln(Lambda)|(M,z)>/sqrt(2*sigma_lnL^2) =
!	! w/ sigma_lnL^2 = 1/exp(< ln lambda|M,z> ) + \sigma^2 ====
!	! p = fraction of halo which is not affect by =============
!	! projection effects ======================================
!	! eps = fraction of Lambda contaminated by projection =====
!	function Phi_M(halo_mass)
!	double precision halo_mass, x_min, x_max, sigma2_lnL, Phi_M_1,Phi_M_2,Phi_M
!	double precision sig2_lnl_z,sig2_intr
!	double precision sigma2_ln_richenss ! This two quantity is defined to approximate a Gaussian with a LogNormal

!    sigma2_ln_richenss = log(1.d0 + (sigma_lambda(halo_mass,redshift))**2.d0)*exp(-LnLambda_M(halo_mass,redshift))**2.d0
!    sig2_intr=sig_intr**2.d0
!    sigma2_lnL =sig2_intr + 1.d0/(exp(LnLambda_M(halo_mass,redshift))-1.d0)
!    if (exp(LnLambda_M(halo_mass,redshift))< 1.d0) sigma2_lnL =sig2_intr
!    sigma2_lnL = sigma2_lnL + sigma2_ln_richenss ! Add the variance due to richenss-error
!    x_min = (LnLambda_min-LnLambda_M(halo_mass,redshift)+sigma2_ln_richenss)/sqrt(2.d0*sigma2_lnL)
!    x_max = (LnLambda_max-LnLambda_M(halo_mass,redshift)+sigma2_ln_richenss)/sqrt(2.d0*sigma2_lnL)
!    Phi_M_1 = 0.5d0*frac_p*(derfc(x_min)-derfc(x_max))
!    x_min = (LnLambda_min+log(1.d0-epsi)-LnLambda_M(halo_mass,redshift)+sigma2_ln_richenss)/sqrt(2.d0*sigma2_lnL)
!    x_max = (LnLambda_max+log(1.d0-epsi)-LnLambda_M(halo_mass,redshift)+sigma2_ln_richenss)/sqrt(2.d0*sigma2_lnL)
!    Phi_M_2 = 0.5d0*(1.d0-frac_p)*(derfc(x_min)-derfc(x_max))
!    Phi_M = Phi_M_1 + Phi_M_2
!!	write(*,'(10e16.8)') redshift,log10(halo_mass),sigma2_lnL,erfc(x_min),erfc(x_max),Phi_M
!	return
!	end function Phi_M
!	! =========================================================

!	! Probability of having a halo of mass M with =============
!	! Lambda MOCK within a given range \Delta_Lambda ==========
!	! For P(Lambda|M) Lognormal : =============================
!	! Phi_M = p/2 * {erfc[x(Lambda_min)]-erfc[x(Lambda_max)]} =
!	! + (1-p)/2 * {erfc[x(Lambda_min*(1-eps))] ================
!	! -erfc[x(Lambda_max*(1-eps))]} ===========================
!	! w\ x =Ln(Lambda)-<Ln(Lambda)|(M,z)>/sqrt(2*sigma_lnL^2) =
!	! w/ sigma_lnL^2 = 1/exp(< ln lambda|M,z> ) + \sigma^2 ====
!	! p = fraction of halo which is not affect by =============
!	! projection effects ======================================
!	! eps = fraction of Lambda contaminated by projection =====
!	function Phi_M(halo_mass)
!	double precision halo_mass, x_min, x_max, sigma2_lnL, Phi_M_1,Phi_M_2,Phi_M
!	double precision sig2_lnl_z,sig2_intr,mean_lognorm
!	double precision sigma2_ln_richenss ! This two quantity is defined to approximate a Gaussian with a LogNormal

!    ! TO MATCH SDSS MOCK
!    sigma2_ln_richenss = log(1.d0 + (sigma_lambda(halo_mass,redshift))**2.d0)*exp(-LnLambda_M(halo_mass,redshift))**2.d0
!    sig2_intr=sig_intr**2.d0
!    sigma2_lnL =sig2_intr + 1.d0/(exp(LnLambda_M(halo_mass,redshift)))
!    if (exp(LnLambda_M(halo_mass,redshift))< 1.d0) sigma2_lnL =sig2_intr
!    mean_lognorm= LnLambda_M(halo_mass,redshift)-2.d0*sigma2_lnL
!    sigma2_lnL = sigma2_lnL + sigma2_ln_richenss ! Add the variance due to richenss-error
!    x_min = (LnLambda_min-mean_lognorm+sigma2_ln_richenss)/sqrt(2.d0*sigma2_lnL)
!    x_max = (LnLambda_max-mean_lognorm+sigma2_ln_richenss)/sqrt(2.d0*sigma2_lnL)
!    Phi_M_1 = 0.5d0*frac_p*(derfc(x_min)-derfc(x_max))
!    x_min = (LnLambda_min+log(1.d0-epsi)-LnLambda_M(halo_mass,redshift)+sigma2_ln_richenss)/sqrt(2.d0*sigma2_lnL)
!    x_max = (LnLambda_max+log(1.d0-epsi)-LnLambda_M(halo_mass,redshift)+sigma2_ln_richenss)/sqrt(2.d0*sigma2_lnL)
!    Phi_M_2 = 0.5d0*(1.d0-frac_p)*(derfc(x_min)-derfc(x_max))
!    Phi_M = Phi_M_1 + Phi_M_2
!!	write(*,'(10e16.8)') redshift,log10(halo_mass),sigma2_lnL,erfc(x_min),erfc(x_max),Phi_M
!	return
!	end function Phi_M
!	! =========================================================


!	! Observable-Mass relation ================================
!	! For mock lambda data ====================================
!	! <Ln(Lambda)|(M,z)> = ln100 + Ln(M/Mref) =================
!	function LnLambda_M(halo_mass,z_reds)
!	double precision halo_mass, LnLambda_M,z_reds,b0,a0

!!	a0= 1.06796914402d0! Fitting 3 params correct
!!	b0= 3.07819484597d0! Fitting 3 params correct
!!	a0= 1.06018141428d0! Fitting 3 params
!!	b0= 3.06881748751d0! Fitting 3 params
!!	a0= 1.064711951d0! Fitting 5 params p>0.9
!!	b0= 3.0559496947d0! Fitting 5 params p>0.9
!!	a0= 1.06397477922d0! Fitting 5 params p>0.2
!!	b0= 3.01562013409d0! Fitting 5 params p>0.2
!	a0= 1.07170373607d0! Fitting 5 params eps>0.25 correct
!	b0= 3.07593954424d0! Fitting 5 params eps>0.25 correct

!	LnLambda_M=b0*(1.d0+delta_b0) + log(halo_mass/2.d14)*a0*(1.d0+delta_a0)
!!	LnLambda_M=log(100.d0)*(1.d0+delta_b0) + log(halo_mass/1.d15)*(1.d0+delta_a0)
!!	LnLambda_M=3.06257637197d0 + log(halo_mass/2.d14)*1.07031249437 ! Fitting 5 params
!!	LnLambda_M=3.05406430478d0 + log(halo_mass/2.d14)*1.04993978686d0 ! Fitting 7 params
!	return
!	end function LnLambda_M
!	! =========================================================


!	! Probability of having a halo of mass M with =============
!	! Lambda MOCK within a given range \Delta_Lambda ==========
!	! For P(Lambda|M) Normal : ================================
!	! Phi_M = p/2 * {erfc[x(Lambda_min)]-erfc[x(Lambda_max)]} =
!	! + (1-p)/2 * {erfc[x(Lambda_min/(1+eps))] ================
!	! -erfc[x(Lambda_max/(1+eps))]} ===========================
!	! w\ x =Lambda-<(Lambda)|(M,z)>/sqrt(2*sigma_L^2) =========
!	! w/ sigma_L^2 = (<lambda|M,z>-1)+(\sigma<lambda|M,z>)^2 ==
!	! p = fraction of halo which is not affect by =============
!	! projection effects ======================================
!	! eps = (Lambda^ob-Lambda^true)/Lambda^true ===============
!	function Phi_M(halo_mass)
!	double precision halo_mass, x_min, x_max, sigma2_L, Phi_M_1,Phi_M_2,Phi_M
!	double precision sig2_lnl_z,sig2_intr,Lambda_M,sigma2_L_2
!!	double precision, optional 

!    Lambda_M=exp(LnLambda_M(halo_mass,redshift))
!    sig2_intr=sig_intr**2.d0
!!    sigma2_L =sig2_intr*(Lambda_M-1.d0)**2.d0 + (Lambda_M-1.d0) ! Questo qllo giusto in generale
!    sigma2_L =sig2_intr*(Lambda_M)**2.d0 + (Lambda_M-1.d0)
!    if (Lambda_M< 1.d0) sigma2_L =sig2_intr*Lambda_M**2.d0
!    sigma2_L = sigma2_L + (sigma_lambda(halo_mass,redshift))**2.d0 ! Add variance due to richenss-error
!    sigma2_L_2=sigma2_L*(1.d0+epsi)**2.d0 + (sigma_lambda(halo_mass,redshift))**2.d0
!    x_min = (exp(LnLambda_min)-Lambda_M)/sqrt(2.d0*sigma2_L)
!    x_max = (exp(LnLambda_max)-Lambda_M)/sqrt(2.d0*sigma2_L)
!    Phi_M_1 = 0.5d0*frac_p*(derfc(x_min)-derfc(x_max))
!    x_min = (exp(LnLambda_min)-Lambda_M*(1.d0+epsi))/sqrt(2.d0*sigma2_L_2)
!    x_max = (exp(LnLambda_max)-Lambda_M*(1.d0+epsi))/sqrt(2.d0*sigma2_L_2)
!    Phi_M_2 = 0.5d0*(1.d0-frac_p)*(derfc(x_min)-derfc(x_max))
!    Phi_M = Phi_M_1 + Phi_M_2
!!	write(*,'(10e16.8)') redshift,log10(halo_mass),sigma2_lnL,erfc(x_min),erfc(x_max),Phi_M
!	return
!	end function Phi_M
!	! =========================================================


!	! For P(Lambda_ob|M,z) = \int dlambda_tr P(lambda_ob| =====
!	! lambda_tr,z_tr) P(lambda_tr|M,z_tr), where ==============
!	! P(lambda_ob|lambda_tr,z_tr) = Normal  ===================
!	! P(lambda_tr|M,z_tr) = p P_0(lambda_tr|M,z_tr) + =========
!	! + (1-p) P_0(lambda_tr(1-eps)|M,z_tr) ====================
!	! P_0(lambda_tr|M,z_tr) = Normal  =========================
!	! lambda_tr_NOPRJ = lambda_tr(1-eps) ======================
!	! p = fraction of halo which is not affect by =============
!	! projection effects ======================================
!	! eps = (Lambda^ob-Lambda^true)/Lambda^true ===============
!	function P_l_ob_M_z(lambda_ob)
!	double precision lambda_ob, sigma2_L, P_M_1,P_M_2,P_l_ob_M_z
!	double precision sig2_intr,Lambda_M,sigma2_L_2

!    Lambda_M=exp(LnLambda_M(mass,redshift)) ! <lambda_tr_NOPRJ|M,z> mass\redshift = global variables
!    sig2_intr=sig_intr**2.d0
!    sigma2_L =sig2_intr*(Lambda_M-1.d0)**2.d0 + (Lambda_M-1.d0) ! Questo qllo giusto in generale
!!    sigma2_L =sig2_intr*(Lambda_M)**2.d0 + (Lambda_M-1.d0)
!    if (Lambda_M< 1.0d0) sigma2_L =sig2_intr*0.001d0**2.d0
!    sigma2_L = sigma2_L + (sigma_lambda(mass,redshift))**2.d0 ! Add variance due to richenss-error
!    sigma2_L_2=sigma2_L/(1.d0-epsi)**2.d0 + (sigma_lambda(mass,redshift))**2.d0
!    P_M_1 = frac_p*exp(-0.5d0*(lambda_ob-Lambda_M)**2.d0/sigma2_L)/sqrt(2.d0*pi_value*sigma2_L)
!    P_M_2 = (1.d0-frac_p)*exp(-0.5d0*(lambda_ob-Lambda_M/(1.d0-epsi))**2.d0/sigma2_L_2)/sqrt(2.d0*pi_value*sigma2_L_2)
!    if (task .ne. 4) then
!        P_l_ob_M_z = P_M_1 + P_M_2
!    else
!        P_l_ob_M_z = P_M_2
!    end if
!!	write(*,'(10e16.8)') redshift,log10(halo_mass),sigma2_lnL,erfc(x_min),erfc(x_max),Phi_M
!	return
!	end function P_l_ob_M_z
!	! =========================================================

!	! fraction of masked clusters =============================
!	function f_MASK(lambda_ob,z_true)
!	implicit none
!	double precision lambda_ob,z_true,f_MASK
!	f_MASK= 0.d0*lambda_ob*(1+z_true)
!	return
!	end function f_MASK
!	! =========================================================

!	! (1 - f_MASK(lambda_ob,z_tr))*P(Lambda_ob|M,z_tr) =========
!	function dPhi_M(lambda_ob)
!	implicit none
!	double precision lambda_ob,dPhi_M
!	dPhi_M=(1.d0 - f_MASK(lambda_ob,redshift))*P_l_ob_M_z(lambda_ob)
!	return
!	end function dPhi_M
!	! =========================================================

!	! \int_Delta_lambda_ob dlambda_ob * =======================
!	! * (1-f_MASK(lambda_ob,z_tr)) * P(Lambda_ob|M,z) =========
!	function Phi_M(halo_mass)
!    implicit none
!    double precision halo_mass,Phi_M
!    double precision epsabs, epsrel, abserr
!    integer neval, ier
!    epsabs = 0.0E+00
!    epsrel = 0.001E+00
!    mass=halo_mass ! Assign global variable
!    call qags (dPhi_M, exp(LnLambda_min),exp(LnLambda_max), epsabs, epsrel, Phi_M, abserr, neval, ier )
!    return
!	end function Phi_M
!	! =========================================================


!	! Probability of having a halo of mass M with =============
!	! Lambda MOCK within a given range \Delta_Lambda ==========
!	! For P(Lambda|M) Normal : ================================
!	! Phi_M = p/2 * {erfc[x(Lambda_min)]-erfc[x(Lambda_max)]} =
!	! + (1-p)/2 * {erfc[x(Lambda_min/(1+eps))] ================
!	! -erfc[x(Lambda_max/(1+eps))]} ===========================
!	! w\ x =Lambda-<(Lambda)|(M,z)>/sqrt(2*sigma_L^2) =========
!	! w/ sigma_L^2 = (<lambda|M,z>-1)+(\sigma<lambda|M,z>)^2 ==
!	! p = fraction of halo which is not affect by =============
!	! projection effects ======================================
!	! eps = (Lambda^ob-Lambda^true)/Lambda^true ===============
!	function Phi_M(halo_mass)
!	double precision halo_mass, x_min, x_max, sigma2_L, Phi_M_1,Phi_M_2,Phi_M
!	double precision sig2_intr,Lambda_M,sigma2_L_2

!    Lambda_M=exp(LnLambda_M(halo_mass,redshift))
!    sig2_intr=sig_intr**2.d0
!    sigma2_L =sig2_intr*(Lambda_M-1.d0)**2.d0 + (Lambda_M-1.d0) ! Questo qllo giusto in generale
!!    sigma2_L =sig2_intr*(Lambda_M)**2.d0 + (Lambda_M-1.d0)
!    if (Lambda_M< 1.0d0) sigma2_L =sig2_intr*0.001d0**2.d0
!    sigma2_L = sigma2_L + (sigma_lambda(halo_mass,redshift))**2.d0 ! Add variance due to richenss-error
!    sigma2_L_2=sigma2_L/(1.d0-epsi)**2.d0 + (sigma_lambda(halo_mass,redshift))**2.d0
!    x_min = (exp(LnLambda_min)-Lambda_M)/sqrt(2.d0*sigma2_L)
!    x_max = (exp(LnLambda_max)-Lambda_M)/sqrt(2.d0*sigma2_L)
!    Phi_M_1 = 0.5d0*frac_p*(derfc(x_min)-derfc(x_max))
!    x_min = (exp(LnLambda_min)-Lambda_M/(1.d0-epsi))/sqrt(2.d0*sigma2_L_2)
!    x_max = (exp(LnLambda_max)-Lambda_M/(1.d0-epsi))/sqrt(2.d0*sigma2_L_2)
!    Phi_M_2 = 0.5d0*(1.d0-frac_p)*(derfc(x_min)-derfc(x_max))
!    Phi_M = Phi_M_1 + Phi_M_2
!!	write(*,'(10e16.8)') redshift,log10(halo_mass),sigma2_lnL,erfc(x_min),erfc(x_max),Phi_M
!	return
!	end function Phi_M
!	! =========================================================



!	! Observable-Mass relation from WL-mass paper SV1 =========
!	function LnLambda_M(halo_mass,z_reds)
!	double precision halo_mass, LnLambda_M,z_reds,b0,a0

!	LnLambda_M=delta_b0 + log(halo_mass/(1.60d14*0.7d0))*delta_a0+ log((1.d0+z_reds)/(1.d0+0.5d0))*delta_c0
!	return
!	end function LnLambda_M
!	! =========================================================

!	! Richness estimate error =================================
!	function sigma_lambda(halo_mass,z_reds)
!	double precision sigma_lambda,halo_mass,z_reds
!	double precision pow

!	! The best fit values have been obtained fitting the ======
!	! SDSS Redmapper v5.10 Cosmological sample with lambda>20 =
!	! and 0.1 < z < 0.33 ======================================
!	
!	pow= -0.79672317d0*z_reds**2.d0 + 0.81044269d0*z_reds + 0.16613417d0
!	
!	sigma_lambda = exp(LnLambda_M(halo_mass,z_reds))**pow
!!	sigma_lambda = 0.d0
!	return
!	end function sigma_lambda


!	! Observable-Mass relation from arXiv:1601.05773 ==========
!	! <Ln(Lambda)|(M,z)> = Ln(Lambda*)+1/alpha*Ln(M/Mref) - ===
!	! - p/alpha-beta/alpha*Ln[(1+z)/(1+z_p)] ==================
!	function LnLambda_M(halo_mass,z_redshift)
!	double precision halo_mass, z_redshift,LnLambda_M
!	double precision alpha,beta,pic,z_p,lambda_p
!	
!	alpha=1.33d0
!	beta=0.48d0
!	pic=log(1.26d0)
!	z_p=0.2d0
!	lambda_p=30.d0
!	
!	
!	LnLambda_M=log(lambda_p)+1.d0/alpha*log(halo_mass/1.d14)-pic/alpha-beta/alpha*(log(1.d0+z_redshift)-log(1.d0+z_p))
!	return
!	end function LnLambda_M
!	! =========================================================

!	! Probability of having a halo of mass M with =============
!	! Lambda within a given range \Delta_Lambda ===============
!	! Phi_M = int_\Delta_Lambda d Lambda P(Lambda|M) ==========
!	! Continuous version of Eq. 3 of Rozo+ 08 =================
!	! For P(Lambda|M) Lognormal : =============================
!	! Phi_M = 1/2 * {erfc[x(Lambda_min)]-erfc[x(Lambda_max)]} =
!	! w\ x =Ln(Lambda)-<Ln(Lambda)|(M,z)>/sqrt(2*sigma_lnL^2) =
!	! w/ sigma_lnL^2 = 1/exp(< ln lambda|M,z> ) + \sigma^2 ====
!	function Phi_M(halo_mass)
!	double precision halo_mass, x_min, x_max, sigma2_lnL, Phi_M
!	double precision p_m,p_z,sig2_lnl_0,sig2_lnl_z,sig2_intr

!    p_m=8.97614763442e+13 ! penso che questa pivot mass si puo togliere
!    p_z=0.135d0 ! test Buzzard Sym
!    sig2_lnl_0=0.0628628121313d0 ! test Buzzard Sym
!    sig2_lnl_z=-0.0762834279179d0 ! test Buzzard Sym
!    sig2_intr=(sig2_lnl_0+sig2_lnl_z*(redshift-p_z)) ! test Buzzard Sym
!    if (sig2_intr < 0.d0) sig2_intr=0.d0 ! test Buzzard Sym To avoid negative values
!    sigma2_lnL =sig2_intr + exp(-LnLambda_M(halo_mass,redshift)) ! test Buzzard Sym
!    if (exp(LnLambda_M(halo_mass,redshift))< 1.d0) sigma2_lnL =sig2_intr +1.d0
!    x_min = (LnLambda_min-LnLambda_M(halo_mass,redshift))/sqrt(2.d0*sigma2_lnL)
!    x_max = (LnLambda_max-LnLambda_M(halo_mass,redshift))/sqrt(2.d0*sigma2_lnL)
!    Phi_M = 0.5d0*(derfc(x_min)-derfc(x_max))
!!	write(*,'(10e16.8)') redshift,log10(halo_mass),sigma2_lnL,erfc(x_min),erfc(x_max),Phi_M
!	return
!	end function Phi_M
!	! =========================================================

!	! Observable-Mass relation ================================
!	! <Ln(Lambda)|(M,z)> = a + b*Ln(M/Mref) + c*Ln(E(z)) ======
!	function LnLambda_M(halo_mass,z_redshift)
!	double precision halo_mass, z_redshift,scale_fac,LnLambda_M
!	double precision alpha_0,alpha_z,beta_0,beta_z 

!    alpha_0 =0.837069083206 ! test Buzzard Sym
!    alpha_z =  0.0640390944694 ! test Buzzard Sym
!    beta_0 =  2.78171199029 ! test Buzzard Sym
!    beta_z =  0.0578843159182 ! test Buzzard Sym

!	scale_fac=1.d0/(1.d0+z_redshift) !scale factor
!!	write(*,*) 'reds enters',redshift
!!	LnLambda_M= a + b*log(halo_mass/M_ref) + c*0.5d0*log(e(scale_fac)) ! NB 0.5 is due to the fact that e(a)= E(z)^2 ! test Buzzard Sym
!	LnLambda_M=beta_0+beta_z*erf((z_redshift-0.340d0)*100.d0)+(alpha_0+alpha_z*erf((z_redshift-0.340)*100.))*log(halo_mass/8.e13) ! test Buzzard Sym
!	return
!	end function LnLambda_M
!	! =========================================================

!	! Observable-Mass relation ================================
!	! Linear relation fitted for alpha(z) and =================
!	! \beta(z) from Buzzard with M200c min = 8.e13 ============
!	! <Ln(Lambda)|(M,z)> = \beta(z) + \alpha(z)*Ln(M/Mref) ====
!	function LnLambda_M(halo_mass,z_redshift)
!	double precision halo_mass, z_redshift,scale_fac,LnLambda_M
!	double precision alpha_0,alpha_z,beta_0,beta_z 

!    alpha_0 =0.859523614403*(1.d0+delta_a0) ! test Buzzard Sym
!    alpha_z =  0.259453974624 ! test Buzzard Sym
!    beta_0 =  2.79974834928*(1.d0+delta_b0) ! test Buzzard Sym
!    beta_z =  0.244858830222 ! test Buzzard Sym

!	LnLambda_M=(beta_0+beta_z*(z_redshift-0.45d0))+(alpha_0+alpha_z*(z_redshift-0.45d0))*log(halo_mass/8.d13) ! test Buzzard Sym
!	return
!	end function LnLambda_M
!	! =========================================================



!    ! test Buzzard Sym TO USE DIRECTLY THE FITTED PERAMETER ===
!	! Observable-Mass relation ================================
!	! <Ln(Lambda)|(M,z)> = a + b*Ln(M/Mref) + c*Ln(E(z)) ======
!	function LnLambda_M(halo_mass,z_redshift)
!	double precision halo_mass, z_redshift,LnLambda_M
!	double precision alpha_z,beta_z 

!    if (z_redshift>=0.1d0 .and. z_redshift<0.2d0) then
!        alpha_z =0.7657782d0
!        beta_z =2.72329263d0
!    else if (z_redshift>=0.2d0 .and. z_redshift<0.3d0) then
!        alpha_z =0.77995609d0
!        beta_z =2.73559168d0
!    else if (z_redshift>=0.3d0 .and. z_redshift<0.4d0) then
!        alpha_z =0.86228593d0
!        beta_z =2.76952471d0
!    else if (z_redshift>=0.4d0 .and. z_redshift<0.5d0) then
!        alpha_z =0.89151986d0
!        beta_z =2.84500773d0
!    else if (z_redshift>=0.5d0 .and. z_redshift<0.6d0) then
!        alpha_z =0.89929889d0
!        beta_z =2.82742636d0
!    else if (z_redshift>=0.6d0 .and. z_redshift<0.7d0) then
!        alpha_z =0.90677407d0
!        beta_z =2.82342167d0
!    else
!        alpha_z =0.91105227d0
!        beta_z =2.87397366d0
!    end if

!	LnLambda_M=beta_z+alpha_z*log(halo_mass/8.e13)! test Buzzard Sym
!	return
!	end function LnLambda_M
!	! =========================================================


	! =========================================================
	! If P(Lambda|M) not Lognormal uncomment the following ====
	! two functions and write the eqution for P(Lambda|M) =====
	! =========================================================
!	! Probability of having a halo of mass M with =============
!	! Lambda within a given range \Delta_Lambda ===============
!	! Phi_M = int_\Delta_Lambda d Lambda P(Lambda|M) ==========
!	! Continuous version of Eq. 3 of Rozo+ 08 =================
!	function Phi_M(halo_mass)
!	double precision halo_mass, Phi_M
!	integer neval, ier
!	double precision epsabs, epsrel, abserr
!    epsabs = 0.0E+00
!    epsrel = 0.001E+00
!    mass=halo_mass ! Assign the Global Variable
!    ! Integration in d Ln(Lambda)
!    call qags (P_Lambda_M, LnLambda_min,LnLambda_max, epsabs, epsrel, Phi_M, abserr, neval, ier )
!	return
!	end function Phi_M
!	! =========================================================

!	! Probability that a halo of mass M has the observed ======
!	! property Lambda =========================================
!	! P(Lambda|M) = 1/(Lambda*sqrt(2*pi*sigma_lnL^2)) * =======
!	! *exp[(Ln(Lambda)-<Ln(Lambda)|(M,z)>)^2/(2*sigma_lnL^2)] =
!	! w/ sigma_lnL^2 = 1/exp(< ln lambda|M,z> ) + \sigma^2] ===
!	function P_Lambda_M(ln_lambda)
!	double precision ln_lambda,sigma2_lnL,P_Lambda_M
!	! NB mass and redshift are Global Variables
!	sigma2_lnL= exp(-LnLambda_M(mass,redshift)) + sigma2_L
!	P_Lambda_M = 1/sqrt(2*pi_value*sigma2_lnL)*exp(-0.5*(ln_lambda-LnLambda_M(mass,redshift))**2.d0/sigma2_lnL)
!	! NB 1/Lambda is absorbed in the integration from dln(Lambda)=dLambda/Lambda
!	return
!	end function P_Lambda_M
!	! =========================================================



end module Phi_of_m
